---
title: "Streamlit 1.53 is here! üéâ"
subtitle: " Starlette integration, access tokens, and per-user caching"
date: 2026-01-14
authors:
  - "Johannes Rieke"
category: "Release Notes"
---

![Streamlit 1.53 release notes hero](./app/static/articles/2026-01-14-1-53-0-release-notes/hero.png)

Streamlit 1.53 is out. If you‚Äôre building on Snowflake, juggling per-user state, or dreaming of running Streamlit inside a bigger ASGI stack, this one‚Äôs for you. üéà

**TL;DR**

- üåê Starlette server mode + ASGI entry point (`st.App`) (experimental)
- üîë OIDC access tokens can be exposed via `st.user.tokens`
- üíæ Session-scoped `st.cache_data` / `st.cache_resource` + cleanup via `on_release`
- ‚ùÑÔ∏è Caller‚Äôs rights connections for Streamlit in Snowflake

Want the full list? Jump to the official [release notes](https://docs.streamlit.io/develop/quick-reference/release-notes).

## üåê Starlette integration + `st.App`

Two _experimental_ building blocks landed for folks who want Streamlit to play nicely in a broader Python web world:

- **`server.useStarlette`**: experimental support for running Streamlit with Starlette (configured in `.streamlit/config.toml`).
- **`st.App`**: an experimental ASGI-compatible entry point with custom routes, middleware, and lifecycle hooks (plus integration with FastAPI/Starlette). See [#13537](https://github.com/streamlit/streamlit/pull/13537) and the spec link from the release notes: [`st.App`](https://issues.streamlit.app/spec_renderer?pr=13449).

### Why this matters

This unlocks the stuff you expect in the ASGI world: mounting Streamlit under FastAPI/Starlette, sharing middleware, and adding ‚Äúboring but necessary‚Äù routes like health checks.

### Starlette integration

Long term, we‚Äôre planning to switch Streamlit apps to run on Starlette by default. For now, it‚Äôs **opt-in** while we harden compatibility.

```toml
[server]
useStarlette = true
```

If you try this and hit anything weird (auth redirects, WebSocket/proxy issues, headers, caching quirks, component behavior, anything), please post it here: [Starlette and ASGI discussion](https://github.com/streamlit/streamlit/issues/13600).

### `st.App`

`st.App` is the other half: an **ASGI-compatible entry point** so you can attach Streamlit to a broader app and add ‚Äúreal web app‚Äù affordances like routes and middleware. Since this is experimental, you need to import it via `from streamlit.starlette import App` for now.

Example: add a couple HTTP routes next to your Streamlit UI.

```python
from streamlit.starlette import App
from starlette.responses import JSONResponse
from starlette.routing import Route

async def health_check(request):
    return JSONResponse({"status": "healthy", "service": "streamlit-app"})

async def get_data(request):
    return JSONResponse({"items": ["apple", "banana", "cherry"], "count": 3})

app = App(
    "main.py",
    routes=[
        Route("/api/health", health_check),
        Route("/api/data", get_data),
    ],
)
```

Other example use cases:

- Add middleware (security headers, auth, logging, tracing)
- Add lifespan hooks for startup/shutdown (pre-warm caches, init resources)
- Mount FastAPI + Streamlit together (either direction)

## üîë Auth: `st.user.tokens`

If you‚Äôre using OIDC auth, you can now optionally expose an **access token** in `st.user.tokens`. This is handy when your app needs to call external APIs **on behalf of the logged-in user**.

Typical use cases: call **Microsoft Graph / Google APIs** as the user, or hit your own OIDC-protected backend without asking people for API keys.

`.streamlit/secrets.toml`:

```toml
[auth]
...
expose_tokens = "access"
```

App code:

```python
import streamlit as st

if not st.user.is_logged_in:
    if st.button("Log in"):
        st.login()
else:
    if st.button("Make API call on my behalf"):
        access_token = st.user.tokens["access"]
        headers = {"Authorization": f"Bearer {access_token}"}
        requests.get("https://example.com/api/me", headers=headers, timeout=30)
```

Docs: [`st.user`](https://docs.streamlit.io/develop/api-reference/user/st.user).

_PS:_ You can also expose the **ID token** via `expose_tokens="id"` (or `["access", "id"]`).

## üíæ Session-scoped caching + cleanup hooks

Two related upgrades landed in 1.53.0:

- **Session-scoped caches** for both `st.cache_data` and `st.cache_resource`
- **Cleanup hooks** for `st.cache_resource` via `on_release` (great for closing per-session stuff)

Global caches are awesome‚Ä¶ until your data is **user-specific**. Session-scoped caching gives you the same speedups while keeping cached results isolated per session. Great for:

- per-user preferences / feature flags
- per-user API calls where responses differ by identity
- resources you _don‚Äôt_ want shared across users (clients, connections, models with user context)

Session-scoped resource cache + cleanup:

```python
import streamlit as st

@st.cache_resource(scope="session", on_release=lambda sess: sess.close())
def get_session():
    # Create a per-user resource (db session, client, etc.).
    return make_session()
```

Docs: [`st.cache_data`](https://docs.streamlit.io/develop/api-reference/caching-and-state/st.cache_data) and [`st.cache_resource`](https://docs.streamlit.io/develop/api-reference/caching-and-state/st.cache_resource).

## ‚ùÑÔ∏è Caller‚Äôs rights connections

Caller‚Äôs rights means your app queries Snowflake **as the currently logged-in user**, not as a shared service user.

When you run Streamlit in Snowflake with caller‚Äôs rights enabled, you can create a **session-scoped** connection that uses the _current user‚Äôs_ identity.

```python
import streamlit as st

# Caller's rights credentials are short-lived, so create this early.
conn = st.connection("snowflake-callers-rights")

df = conn.query("SELECT CURRENT_USER() AS user, CURRENT_ROLE() AS role")
st.dataframe(df, hide_index=True, use_container_width=True)
```

More details (and the important caveat about creating the connection near the top of your app): [`st.connections.SnowflakeConnection`](https://docs.streamlit.io/develop/api-reference/connections/st.connections.snowflakeconnection).

## A few more goodies

- **Better value formatting for sliders** via `format=` in [`st.slider`](https://docs.streamlit.io/develop/api-reference/widgets/st.slider)
- **Icons in dialogs** via `icon=` in [`st.dialog`](https://docs.streamlit.io/develop/api-reference/execution-flow/st.dialog)
- **More control over row adds/deletes** in `st.data_editor(num_rows="add" | "delete")` ([`st.data_editor`](https://docs.streamlit.io/develop/api-reference/data/st.data_editor))

## Wrapping up

That‚Äôs it for 1.53.0. If you try Starlette mode / `st.App`, please share bugs + feedback in the GitHub thread above.

Catch everything else in the official [release notes](https://docs.streamlit.io/develop/quick-reference/release-notes).

Happy Streamlit-ing! üéà
